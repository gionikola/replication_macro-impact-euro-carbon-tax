# Load necessary packages 
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyr,
               dplyr, 
               stats,
               vars, 
               ggplot2,
               readr,
               rio,
               lpirfs,
               panelvar,
               svglite) 

# `scale_irfs()`
# Scales input `lpirfs_lin_panel_obj` IRF
# point estimates and CIs by a scaling factor.
scale_irfs <- function(irf_obj, scale_factor){
  
  irf_obj[1][[1]] <- irf_obj[1][[1]] * scale_factor
  irf_obj[2][[1]] <- irf_obj[2][[1]] * scale_factor
  irf_obj[3][[1]] <- irf_obj[3][[1]] * scale_factor
  
  return(irf_obj)
}

# `%!in%`
# Operator that returns TRUE when value
# does not match array of inputs
'%!in%' <- function(x,y)!('%in%'(x,y)) 

# `sims`
# Sims counterfactual
# given `lprifs_lin_panel_obj`
# sequence of counterfactual shocks
# and horizon length (+1)
sims <- function(fig, xpath, horizon){
  
  response_sims <- 0 * c(1:horizon)
  
  for(i in 1:horizon){
    if (i == 1){
      response_temp <- fig$irf_panel_mean |> as.vector() 
      response_sims <- xpath[i] * response_temp
    }else{
      response_temp <- fig$irf_panel_mean |> as.vector() |> lag(i-1)
      response_temp <- c(0*c(1:(i-1)),response_temp[i:h])
      response_sims <- xpath[i] * response_temp + response_sims
    }
  }
  
  return(response_sims)
}

# Create standard and cumulative IRF dataframe for easy plotting
create_irf_df <- function(reg_irf, horizon){
  
  temp_df <- data.frame(horizon = c(0:horizon),
                        irf = reg_irf |> as.vector(),
                        cirf = reg_irf |> as.vector() |> cumsum()) |> 
    pivot_longer(
      cols = c("irf","cirf"), 
      names_to = "response_type",
      values_to = "response"
    ) |>
    mutate(response_type = ifelse(response_type=="irf", "Standard IRF", "Cumulative IRF"))
  
  return(temp_df)
}

# Plot IRF dataframe for easy plotting (generated by `create_irf_df`)
create_irf_plot <- function(irf_df,ylimit,cumulative=TRUE){
  
  if(cumulative == FALSE){
    irf_df <- irf_df |>
      filter(response_type = "Standard IRF")
  }
  
  response_plot <- ggplot(irf_df, aes(x=horizon, y=response, linetype=response_type)) +
    geom_line(size=2) +
    theme_classic() +
    #theme(legend.position = "bottom") +
    theme(legend.position = "none") +
    coord_cartesian(expand = FALSE) + 
    theme(text=element_text(size=15)) 
  
  new_response_plot <- response_plot + 
    ylab("Percentage points") +
    xlab("Years after implementation") +
    geom_line(aes(y = 0), col = "black") + 
    scale_color_discrete(name = "Response Type:") +
    ylim(ylimit[1],ylimit[2]) 
  
  return(new_response_plot)
}

# Function for potting counterfactual IRFs for convenience
plot_counter_irf <- function(fig, h, ylimit){
  
  fig_df <- data.frame(
    horizon = c(0:(h-1)),
    mean = fig$irf_panel_mean |> as.vector(),
    ci_lower = fig$irf_panel_low |> as.vector(),
    ci_upper = fig$irf_panel_up |> as.vector(),
    mean_cumul = fig$irf_panel_mean |> as.vector() |> cumsum(),
    mean_counterfactual = sims(fig, xpath, h),
    mean_counterfactual_cumul = sims(fig, xpath, h) |> cumsum()
  )
  
  irf_plot <- ggplot(fig_df) +
    geom_line(aes(x = horizon, y = mean), color = "black", linetype = "dashed", size = 1.5) +
    geom_ribbon(aes(x = horizon, ymin = ci_lower, ymax = ci_upper), fill = "magenta", alpha = 0.2) +
    geom_line(aes(x = horizon, y = mean_cumul), size = 1.5, color = "black", linetype = "solid") +
    geom_line(aes(x = horizon, y = mean_counterfactual), size = 1.5, color = "green", linetype = "dashed") +
    geom_line(aes(x = horizon, y = mean_counterfactual_cumul), size = 1.5, color = "green", linetype = "solid") +
    theme_classic() +
    coord_cartesian(expand = FALSE) + 
    theme(text=element_text(size=15)) + 
    ylab("Percentage points") +
    xlab("Years after implementation") +
    geom_hline(yintercept=0) +
    ylim(ylimit[1],ylimit[2]) 
  
  return(irf_plot)
}